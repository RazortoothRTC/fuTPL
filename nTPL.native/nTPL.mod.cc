/** Part of nTPL* nTPL.modificators v.0.0.1* Copyright 2010, Fedor Indutny* Released under MIT license*/#include <nTPL.mod.h>#include <v8.h>#include <stdio.h>namespace nTPL {	namespace mod {		using namespace v8;		Persistent<FunctionTemplate> constructor_template;				enum OPS_STATE {			STAND_BY = 0,			NAME = 1,			WAITING_ARRAY = 2,			WAITING_VAL = 3		};				#define _PARSER_OP(offset, char) (input[i+offset] == char)		#define _PARSER_MOVE(offset) last=(i+=offset)		#define _GET_SYMB_PART String::NewSymbol( (char*) input + last, i - last )		#define _GET_PART String::New( (char*) input + last, i - last )		#define _SKIP_SPACES do{i++;}while(_PARSER_OP(0, ' '));_PARSER_MOVE(0);		Handle<Value> option(const Arguments& args)		{			HandleScope scope;						Local<String> str = Local<String>::Cast(args[0]);			Local<Object> options = Local<Object>::Cast(args[2]);						String::Utf8Value str_(str);			unsigned char* input = (unsigned char*) *str_;						OPS_STATE state = STAND_BY;						int last = 0;						Local<String> name;			Local<Value> value;			Local<Array> valueA;						int valLength = 0;						for (int i = 0; input[i] ; )				if (state == STAND_BY && !_PARSER_OP(0, ' '))				{					// Found start of option name					_PARSER_MOVE(0); // last = current					state = NAME;				}				else if (state == NAME && _PARSER_OP(0, ' '))				{										name = _GET_SYMB_PART;					value = options->Get(name);										if (value->IsArray())					{						state = WAITING_ARRAY;						valueA = Local<Array>::Cast(value);						valLength = valueA->Length();					} else					{						state = WAITING_VAL;					}										_SKIP_SPACES;				}				else if (state == WAITING_ARRAY && ( _PARSER_OP(0, ' ') || _PARSER_OP(0, ',') || !input[i+1]) )				{					if (!input[i+1])					{						i++;					}										Local<String> t = _GET_PART;										if (t->Length())					{						valueA->Set(valLength++, t);					}										if (!input[i])					{						break;					}										_SKIP_SPACES;									}				else if (state == WAITING_VAL && _PARSER_OP(0, ';'))				{					options->Set(name, _GET_PART);					break;				}				else if (state == WAITING_VAL && !input[i+1])				{					i++;					options->Set(name, _GET_PART);					break;				}				else				{					i++;				}						return scope.Close(String::New(""));		}				#define NEW_MODIFICATOR(name,func) modificators->Set( String::New(name), FunctionTemplate::New(func)->GetFunction() )		Handle<Value> add(const Arguments& args)		{			HandleScope scope;						if (!args[0]->IsObject())			{				return scope.Close(Object::New());			}						Local<Object> modificators = args[0]->ToObject();						NEW_MODIFICATOR("set", option);						return scope.Close(modificators);		}				void init(Handle<Object> target)		{			HandleScope scope;						Local<FunctionTemplate> t = FunctionTemplate::New(add);			constructor_template = Persistent<FunctionTemplate>::New(t);									target->Set(String::NewSymbol("initModificators"), constructor_template->GetFunction());		}	}}