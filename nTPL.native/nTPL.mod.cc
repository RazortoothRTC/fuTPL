/** Part of nTPL* nTPL.modificators v.0.0.1* Copyright 2010, Fedor Indutny* Released under MIT license*/#include <nTPL.mod.h>#include <v8.h>#include <stdio.h>using namespace v8;namespace nTPL {	namespace mod {		Persistent<FunctionTemplate> constructor_template;				static Handle<Value> ops(const Arguments& args)		{			HandleScope scope;						Local<String> str = args[0]->ToString();						String::Utf8Value str_(str);			char* str__ = (char*) *str_;						sprintf(processed, "$p(%s,$_);", str__);						return scope.Close(String::New(""));		}				#define NEW_MODIFICATOR(name,func) modificators->Set( String::New(name), FunctionTemplate::New(func)->GetFunction() )		static Handle<Value> add(const Arguments& args)		{			HandleScope scope;						if (!args[0]->IsObject())			{				return scope.Close(Object::New());			}						Local<Object> modificators = args[0]->ToObject();						NEW_MODIFICATOR("set", ops);						return scope.Close(modificators);		}				static void init(Handle<Object> target) {			HandleScope scope;						Local<FunctionTemplate> t = FunctionTemplate::New(add);			constructor_template = Persistent<FunctionTemplate>::New(t);						target->Set(String::NewSymbol("initModificators"), constructor_template->GetFunction());		}	}}